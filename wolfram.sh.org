:PROPERTIES:
:ID:       1eb149d5-d026-41bc-be8b-700576051fcc
:END:
#+title: wolfram.sh
#+author: Jeff Kreeftmeijer
#+date: 2025-12-15
#+options: ':t toc:nil

An [[https://en.wikipedia.org/wiki/Elementary_cellular_automaton][elementary cellular automaton]], based on the [[https://en.wikipedia.org/wiki/Wolfram_code][Wolfram code]] and implemented as a shell script.

#+toc: headlines

* Usage

#+begin_src bash
./wolfram.sh [options]
#+end_src

- ~-r~ :: Which [[https://atlas.wolfram.com/01/01/rulelist.html][rule]] to use in the simulation.
              Defaults to choosing a random rule.
- ~-w~ :: The /width/ of the simulation.
              Defaults to the number of columns in the terminal.
- ~-g~ :: The number of /generations/ printed.
              Produces generations indefinitely by default.
- ~-d~ :: The /delay/ before printing the next generation.
              Defaults to 0.1 seconds.

#+caption: An example. Print 10 generations of rule 30 in a 20-column wide simulation without a delay.
#+headers: :exports both
#+headers: :results verbatim
#+headers: :cache yes
#+begin_src bash
./wolfram.sh -r 30 -w 20 -g 10 -d 0
#+end_src

#+RESULTS[9caca806c43cfaaa3503e69186b367fc5ecb9665]:
#+begin_example
          █         
         ███        
        ██  █       
       ██ ████      
      ██  █   █     
     ██ ████ ███    
    ██  █    █  █   
   ██ ████  ██████  
  ██  █   ███     █ 
 ██ ████ ██  █   ███
#+end_example

** As a terminal screensaver

An interesting use of wolfram.sh is using it as a "terminal screensaver".

An example using Alacritty opens the terminal in full screen mode, decreases the font size to increase the resolution, and disables the history.
It then starts the program with a random pick from a selection of interesting rules:

#+begin_src bash
alacritty --option font.size=2 \
          --option font.offset={x=3} \
	  --option window.startup_mode='"Fullscreen"' \
	  --option scrolling.history=0 \
	  --command ./wolfram.sh -r $(shuf -e 30 45 60 90 110 150 -n 1)
#+end_src

* Implementation

** Set the initial state

The simulation emerges from an initial configuration of cells, which represent the first generation.
Because the elementary cellular automaton is one-dimensional, its state can be represented as an array.

To generate an initial state, first determine the width of the simulation.

#+caption: Define the ~width~ variable, and set it to the number of columns in the terminal window.
#+name: define-width-variable
#+begin_src bash
width=$(tput cols)
#+end_src

The width is set to the number of columns in the terminal window, but it can be configured with the ~-w~ flag.

#+begin_src bash
while getopts "w:" flag; do
    case "$flag" in
	'w') width=$OPTARG;;
	*) exit
    esac
done
#+end_src

With the ~width~ set, generate the initial state by populating an array with zeroes.
There is one live cell in the middle, represented by a 1 as the middle array element.

#+caption: Set the initial state to an array of zeroes with a single 1 in the middle.
#+name: set-initial-state
#+begin_src bash
for ((i=0;i<=width-1;i++)); do
    state+=($((i == width/2)))
done
#+end_src

<<initial-state>>
For example, running the code above in a terminal that's 9 cells wide produces an initial state with a width of 9 cells, with a single live cell in the middle:

#+header: :cache yes
#+header: :exports results
#+header: :noweb yes
#+header: :results verbatim
#+header: :wrap example
#+begin_src bash
#!/usr/bin/env bash

width=9

<<set-initial-state>>

echo "(${state[@]})"
#+end_src

#+RESULTS[6646493224cfc39d539ba69dcc408b50265fb40b]:
#+begin_example
(0 0 0 0 1 0 0 0 0)
#+end_example

** Draw the current state

The ~draw~ function prints the current state.
Whenever it's called, it prints a line with either ~█~ or a space for each cell in the generation.

#+header: :exports none
#+name: define-live-and-dead-variables
#+begin_src bash
live="█"
dead=" "
#+end_src

#+header: :exports none
#+name: define-draw-function
#+begin_src bash
draw() {
    local line=""
    for value in "$@"; do
          line+=$([ "$value" -eq 1 ] && echo "$live" || echo "$dead");
    done
    printf "%b" "${line}"
}
#+end_src

#+caption: Define the ~draw()~ function
#+header: :noweb yes
#+begin_src bash
<<define-live-and-dead-variables>>

<<define-draw-function>>
#+end_src

To draw the current ~state~, pass it to the ~draw()~ function as an array.

#+name: draw-initial-generation
#+begin_src bash
draw "${state[@]}"
#+end_src

With the [[initial-state][initial state]] state, the ~draw()~ function prints a single box in the middle of the screen to represent a single living cell.

#+header: :cache yes
#+header: :exports results
#+header: :noweb yes
#+header: :results verbatim
#+header: :wrap example
#+begin_src bash
#!/usr/bin/env bash

<<define-draw-function>>

width=9
live="█"
dead="░"

<<set-initial-state>>

<<draw-initial-generation>>
#+end_src

#+RESULTS[e5440cc42527ad506324c9ec7f71bc1834e08b85]:
#+begin_example
░░░░█░░░░
#+end_example

** Calculate cell values

To determine the next state of a cell, the program considers the cell's /neighborhood/ in the previous generation.
In the elementary cellular automaton, a cell's neighborhood consists of the cell in the same position in the previous generation, and the cell on the left and right of it.

#+caption: Set the neighborhood for a cell by taking the previous generation's cell value, and the values of the cells to the left and right of it. 
#+name: set-neighborhood
#+begin_src bash
neighborhood=$((state[i-1]))$((state[i]))$((${state[i+1]:-${state[0]}}))
#+end_src

When determining the state of the 5th cell in the second generation, the 4th, 5th and 6th cell in the previous generation are considered its neighborhood.
For example, using the [[initial-state][initial state]], calculating the neighborhood for the 5th element of the second generation:

#+header: :cache yes
#+header: :exports results
#+header: :noweb yes
#+header: :results verbatim
#+begin_src bash
state=(0 0 0 0 1 0 0 0 0)
i=4
<<set-neighborhood>>
echo "${neighborhood}"
#+end_src

#+RESULTS[92e7b46ab439139c6392bb8e7c7d3555830217a9]:
: 010

After finding the neighborhood, a /rule/ is applied to decide what the next state should be.

There are [[https://plato.stanford.edu/entries/cellular-automata/supplement.html][256 rules]] in the elementary cellular automaton, each one derived from is binary representation.
To extract the rule set, the rule number is converted to binary, split into an array, and finally reversed.

#+name: set-ruleset
#+begin_src bash
ruleset=(0 0 0 0 0 0 0 0)
for i in {0..7}; do
    ruleset[i]=$((rule % 2))
    rule=$((rule / 2))
done
#+end_src

For example, setting the ~rule~ variable to 30 produces the ruleset for [[https://en.wikipedia.org/wiki/Rule_30][rule 30]]:

#+header: :cache yes
#+header: :exports results
#+header: :noweb yes
#+header: :results verbatim
#+begin_src bash
rule=30
<<set-ruleset>>
echo "(${ruleset[@]})"
#+end_src

#+RESULTS[5b566c902709a1993d2b6f09ca21f4ba798ee6d2]:
: (0 1 1 1 1 0 0 0)

Finally, with both the ~ruleset~ and ~neighborhood~ set, calculate the value for the new cell and add it to a new array named ~new_state~.
This is done by converting the neighborhood to a decimal value, and using that value as the index to look up the new value in ~ruleset~ array.

#+name: add-to-new-state
#+begin_src bash
new_state+=("${ruleset[$((2#$neighborhood))]}")
#+end_src

** Print new generations

Now that we have the logic to create a ruleset from a rule number and a way to calculate new generation cell values, the program can print new generations in a loop.
For this, it needs to know which rule to use, and how many generations to print.

By default, one of the 256 rules is chosen at random.
The ~generations~ variable is set to 0, which means the program keeps printing new generations until it's terminated manually.
Finally, ~delay~ variable is set to 0.1, which determines how long the program sleeps between drawing generations.

#+name: define-rule-generations-and-delay-variables
#+begin_src bash
rule=$((RANDOM % 256))
generations=0
delay=0.1
#+end_src

The ~rule~, ~generations~ and ~delay~ variables are configurable, through the ~-r~, ~-g~, and ~-d~ command line options, respectively.

#+name: command-line-options
#+begin_src bash
while getopts "d:g:r:w:" flag; do
    case "$flag" in
	'd') delay=$OPTARG;;
	'g') generations=$OPTARG;;
	'r') rule=$OPTARG;;
	'w') width=$OPTARG;;
	*) exit
    esac
done
#+end_src

With everything set up, the program can print generations by populating a ~new_state~ array, populating it, replacing the ~state~ variable, and then printing the new state with the ~draw()~ function in a loop.

#+name: draw-new-generations-in-a-loop
#+header: :noweb yes
#+begin_src bash
count=1

while [ "$generations" = 0 ] || [ $count -lt "$generations" ]; do
    sleep "$delay"
    new_state=()

    for ((i=0;i<=width-1;i++)); do
	<<set-neighborhood>>
        <<add-to-new-state>>
    done

    state=("${new_state[@]}")

    printf "\n"
    draw "${state[@]}"

    ((count++))
done
#+end_src

** Hide the cursor

To prevent flickering while drawing, the program hides the cursor before printing the first generation.
Then, right before exiting, the cursor is set back to normal.

#+name: hide-cursor
#+begin_src bash
hide-cursor() {
    tput civis
}

show-cursor() {
    tput cnorm
}

trap show-cursor EXIT
hide-cursor
#+end_src

* Testing

The program is tested with [[https://github.com/bats-core/bats-core][bats]], a testing framework for bash.
To run the tests, evaluate ~test.bats~.

#+begin_src bash
./test.bats
#+end_src

* Result :noexport:

#+header: :noweb yes
#+header: :tangle wolfram.sh
#+header: :eval no
#+begin_src bash
#!/usr/bin/env bash

<<define-draw-function>>

<<hide-cursor>>

<<define-width-variable>>
<<define-live-and-dead-variables>>
<<define-rule-generations-and-delay-variables>>

<<command-line-options>>

<<set-ruleset>>

<<set-initial-state>>

<<draw-initial-generation>>

<<draw-new-generations-in-a-loop>>
#+end_src

# Local Variables:                                             
# org-src-preserve-indentation: t
# End:
